{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>SimPYson</code> is a Python package developed to streamline the use of SIMPSON, a simulation software for solid-state NMR. Born out of the frustration of trying to learn and use SIMPSON on my own, SimPYson aims to simplify the process of converting DFT calculation results into SIMPSON input files and read Simpson simulation, all within python</p>"},{"location":"index.html#current-features","title":"Current features \ud83e\udd0c","text":"<ul> <li>Convert results from DFT calculations (e.g., CASTEP, Quantum Espresso, VASP) into SIMPSON input files.</li> <li>Read and process output files from SIMPSON simulations.</li> <li>Provide ready-to-use templates for common SIMPSON NMR experiments, such as 90-degree pulse and no-pulse.</li> </ul>"},{"location":"index.html#why-choose-simpyson","title":"Why choose SimPYson? \ud83d\ude4e\u200d\u2642\ufe0f","text":"<p>No particular reason. One possible advantage lies in its seamless integration with other Python packages, making it easy to incorporate into your existing Python workflow. However, depending on your needs/taste, there are a few alternatives that may better suit you, hera are some examples:</p> <ul> <li>Simplot: From the developers of Simpson offers a user-friendly interface to analyze the results.</li> <li>Simview: From Zden\u011bk To\u0161ner (Simpson dev) provides a GUI to run SIMPSON simulations and plot results within a clean, intuitive interface</li> <li>EasyNMR: A cloud-based platform that allows you to run and analyze SIMPSON simulations remotely.</li> </ul>"},{"location":"index.html#future","title":"Future","text":"<p>We are open to suggestions.</p>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#011","title":"[0.1.1]","text":"<ul> <li>Added a GUI for Simpyson</li> <li>Implemented FID to SPE convertion within GUI</li> <li>Implemented Hz to ppm convertion within GUI</li> </ul>"},{"location":"about/changelog.html#010","title":"[0.1.0]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>Tutorial on converting DFT structures to Simpson simulations.</li> <li>Tutorial on reading and processing Simpson simulation results.</li> <li>Added isotopes data to convert from Hz to ppm.</li> <li>Added <code>SimpSim</code> class to prepare Simpson input files.</li> <li>Added <code>read_vasp</code> to convert VASP NMR tensors into a format readable by Soprano.</li> <li>Templates for 90-degree pulse <code>pulse_90</code> and no-pulse <code>no_pulse</code> experiments.</li> </ul>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added_1","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/citation.html","title":"Citing simPYson","text":"<p>If you use <code>SimPYson</code> in your work, please consider citing all the software that makes it possible:</p> <ul> <li>SIMPSON: https://doi.org/10.1016/j.jmr.2011.09.008, https://doi.org/10.1016/j.jmr.2014.07.002, and https://doi.org/10.1016/bs.arnmr.2019.12.001</li> <li>ASE: https://doi.org/10.1088/1361-648X/aa680e</li> <li>Soprano: Acknowledge CCPNC.<ul> <li>This work was facilitated by software tools (specifically Soprano) developed by the Collaborative Computing Project for NMR Crystallography, funded by EPSRC grant EP/T026642/1.</li> </ul> </li> <li>SimPYson: https://doi.org/10.5281/zenodo.14041918</li> </ul> <p>For the most accurate references, please refer to each software\u2019s official website or documentation for citation details.</p>"},{"location":"about/contributors.html","title":"People","text":"<p>SimPYson was originally developed by Carlos Bornes.</p>"},{"location":"about/contributors.html#active-maintainers","title":"Active Maintainers","text":"<p>The currently active maintainers are as follows:</p> <ul> <li>Carlos Bornes</li> <li>M\u00e1rcio Soares:</li> <li>Daniel Pereira:</li> </ul>"},{"location":"about/contributors.html#contributors","title":"Contributors","text":"<p>Additional contributions were made by the individuals listed here.</p>"},{"location":"about/contributors.html#inspiration","title":"Inspiration","text":"<p>Some project that served as inspiration for SimPYson are:</p> <ul> <li> <p>Quantum Accelerators Python package template created by Andrew S. Rosen.</p> </li> <li> <p>Soprano created by CCP-NC, Simone Sturniolo and currently maintained by Kane Shenton.</p> </li> </ul>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p>If you have Python and pip installed, you can easily install SimPYson with the following command:</p> <pre><code>pip install git+https://github.com/nuts-org/simpyson.git\n</code></pre> <p>All dependecies are installed automatically.</p> <p>To verify that the package has been installed successfully, open a Python console and run:</p> <pre><code>import simpyson\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>simpyson<ul> <li>cli</li> <li>converter</li> <li>gui</li> <li>io</li> <li>templates</li> </ul> </li> </ul>"},{"location":"reference/simpyson/cli.html","title":"cli","text":""},{"location":"reference/simpyson/converter.html","title":"converter","text":""},{"location":"reference/simpyson/converter.html#simpyson.converter.hz2ppm","title":"hz2ppm","text":"<pre><code>hz2ppm(hz, b0, nucleus, isotope_file=None)\n</code></pre> <p>Convert Hz values to ppm values.</p> <p>Args:     hz (numpy.ndarray): Frequency values in Hz     b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')     nucleus (str): Nucleus type (e.g., '1H' or '13C')     isotope_file (str, optional): Path to isotope data file. If None, uses default.</p> <p>Returns:     numpy.ndarray: Chemical shift values in ppm</p> <p>Raises:     ValueError: If B0 unit is invalid or nucleus not found</p> Source code in <code>simpyson/converter.py</code> <pre><code>def hz2ppm(hz, b0, nucleus, isotope_file=None):\n    \"\"\"\n    Convert Hz values to ppm values.\n\n    Args:\n        hz (numpy.ndarray): Frequency values in Hz\n        b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')\n        nucleus (str): Nucleus type (e.g., '1H' or '13C')\n        isotope_file (str, optional): Path to isotope data file. If None, uses default.\n\n    Returns:\n        numpy.ndarray: Chemical shift values in ppm\n\n    Raises:\n        ValueError: If B0 unit is invalid or nucleus not found\n    \"\"\"\n\n    if isotope_file is None:\n        dir = os.path.dirname(os.path.realpath(__file__))\n        isotope_file = os.path.join(dir, 'isotope_data.json')\n\n    isotope = int(''.join(filter(str.isdigit, nucleus)))\n    element = ''.join(filter(str.isalpha, nucleus)).capitalize()\n    b0_unit = ''.join(filter(str.isalpha, b0)).lower()\n\n    with open(isotope_file) as f:\n        data = json.load(f)\n        if element in data and str(isotope) in data[element]:\n            gamma = data[element][str(isotope)]['Gamma']\n        else:\n            raise ValueError(f'Nucleus {nucleus} not found in isotope data.')\n\n    if b0_unit == 't':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0)))\n        larm_freq = gamma * 1e7 * b0_value / (2 * np.pi * 1e6)\n        ppm = hz / np.abs(larm_freq)\n    elif b0_unit == 'mhz':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0))) \n        gamma_h = data['H']['1']['Gamma']\n        b0_value_T = 2 * np.pi * b0_value * 1e6 / (gamma_h * 1e7)\n        larm_freq = gamma * 1e7 * b0_value_T / (2 * np.pi * 1e6)\n        # ppm conversion requires absolute value of larm_freq\n        ppm = hz / np.abs(larm_freq)\n    else:\n        raise ValueError('B0 unit must be T or MHz.')\n\n    return ppm\n</code></pre>"},{"location":"reference/simpyson/converter.html#simpyson.converter.ppm2hz","title":"ppm2hz","text":"<pre><code>ppm2hz(ppm, b0, nucleus, isotope_file=None)\n</code></pre> <p>Convert ppm values to Hz values.</p> <p>Args:     ppm (numpy.ndarray): Chemical shift values in ppm     b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')     nucleus (str): Nucleus type (e.g., '1H' or '13C')     isotope_file (str, optional): Path to isotope data file. If None, uses default.</p> <p>Returns:     numpy.ndarray: Frequency values in Hz</p> <p>Raises:     ValueError: If B0 unit is invalid or nucleus not found</p> Source code in <code>simpyson/converter.py</code> <pre><code>def ppm2hz(ppm, b0, nucleus, isotope_file=None):\n    \"\"\"\n    Convert ppm values to Hz values.\n\n    Args:\n        ppm (numpy.ndarray): Chemical shift values in ppm\n        b0 (str): Magnetic field strength (e.g., '400MHz' or '9.4T')\n        nucleus (str): Nucleus type (e.g., '1H' or '13C')\n        isotope_file (str, optional): Path to isotope data file. If None, uses default.\n\n    Returns:\n        numpy.ndarray: Frequency values in Hz\n\n    Raises:\n        ValueError: If B0 unit is invalid or nucleus not found\n    \"\"\"\n\n    if isotope_file is None:\n        dir = os.path.dirname(os.path.realpath(__file__))\n        isotope_file = os.path.join(dir, 'isotope_data.json')\n\n    isotope = int(''.join(filter(str.isdigit, nucleus)))\n    element = ''.join(filter(str.isalpha, nucleus)).capitalize()\n    b0_unit = ''.join(filter(str.isalpha, b0)).lower()\n\n    with open(isotope_file) as f:\n        data = json.load(f)\n        if element in data and str(isotope) in data[element]:\n            gamma = data[element][str(isotope)]['Gamma']\n        else:\n            raise ValueError(f'Nucleus {nucleus} not found in isotope data.')\n\n    if b0_unit == 't':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0)))\n        larm_freq = gamma * 1e7 * b0_value / (2 * np.pi * 1e6)\n    elif b0_unit == 'mhz':\n        b0_value = float(''.join(filter(lambda x: x.isdigit() or x == '.', b0))) \n        gamma_h = data['H']['1']['Gamma']\n        b0_value_T = 2 * np.pi * b0_value * 1e6 / (gamma_h * 1e7)\n        larm_freq = gamma * 1e7 * b0_value_T / (2 * np.pi * 1e6)\n    else:\n        raise ValueError('B0 unit must be T or MHz.')\n\n    hz = ppm * np.abs(larm_freq) \n\n    return hz\n</code></pre>"},{"location":"reference/simpyson/converter.html#simpyson.converter.read_vasp","title":"read_vasp","text":"<pre><code>read_vasp(file, format)\n</code></pre> <p>This function reads NMR data from a VASP OUTCAR file.</p> <p>Args:     file (str): The path to the VASP OUTCAR file.     format (str): The format of the VASP OUTCAR file.</p> <p>Returns:     ase.Atoms: The Atoms object with the NMR data.</p> <p>Example:     reader = read_vasp('OUTCAR', 'vasp-out')</p> Source code in <code>simpyson/converter.py</code> <pre><code>def read_vasp(file, format):\n    \"\"\"\n    This function reads NMR data from a VASP OUTCAR file.\n\n    Args:\n        file (str): The path to the VASP OUTCAR file.\n        format (str): The format of the VASP OUTCAR file.\n\n    Returns:\n        ase.Atoms: The Atoms object with the NMR data.\n\n    Example:\n        reader = read_vasp('OUTCAR', 'vasp-out')\n    \"\"\"\n    filename = ase.io.read(file, format=format)\n    n_atoms = filename.get_global_number_of_atoms()\n    np.set_printoptions(suppress=True)\n    efg = []\n    sym_tensor = []\n    const_shield = []\n    core_shield_dict = []\n    ms = []\n    volume = None\n    with open(file, 'r') as outcar:\n        lines = outcar.readlines()\n        #Find lines with specific header\n        for line in lines:\n            if line.find(\"Electric field gradients (V/A^2)\") != -1:\n                idx_header1 = lines.index(line) #efg\n            if line.find(\"SYMMETRIZED TENSORS\") != -1:\n                idx_header2 = []\n                idx_header2.append(lines.index(line)) #sym tensor - need to take second one (unsym. tensors)\n            if line.find(\"G=0 CONTRIBUTION TO CHEMICAL SHIFT\") != -1:\n                idx_header3 = lines.index(line) #constant shielding\n            if line.find('Core NMR properties') != -1:\n                idx_header4 = lines.index(line) #core NMR prop - depends on atom type\n            if line.find(\"Core contribution to magnetic susceptibility:\") != -1:\n                val = line.split()[5]\n                exp = line.split()[6][-2:]\n                mag_sus = float(val)*10**int(exp)\n            if line.find(\"volume of cell\") != -1 and volume is None:\n                volume = float(line.split()[4])\n\n        chi_fact = 3.0/8.0/np.pi*volume*6.022142e23/1e24 # Conversion factor for magnetic susceptibility\n\n        #Calculate tensors for every atoms\n        for i in range(n_atoms):\n            grad = (lines[idx_header1+4+i]).split()[1:] # V_xx, V_yy, V_zz, V_xy, V_xz, V_yz\n            matrix = np.array([[grad[0],grad[3],grad[4]],   #xx xy xz\n                               [grad[3],grad[1],grad[5]],   #xy yy yz\n                               [grad[4],grad[5],grad[2]]])  #xz yz zz\n            efg.append(matrix)\n\n        for i in range(n_atoms*4):\n            if i % 4 != 0:\n                sym=lines[idx_header2[-1] + i + 1].split()\n                sym_tensor.append(lines[idx_header2[-1] + i + 1].split())\n\n        # Newer version of VASP 6.4.1\n        if lines[idx_header3 + 1].strip() == \"using pGv susceptibility, excluding core contribution\":\n            start_idx = idx_header3 + 5\n        # Older version of VASP\n        else:\n            start_idx = idx_header3 + 4\n\n        for i in range(3):\n            const_shield.append((lines[start_idx + i]).split()[1:])\n\n        for i in range(len(np.unique(filename.get_chemical_symbols()))):\n            core_shield_dict.append((lines[idx_header4 + 4 + i]).split()[1:])\n        core_shield_dict = dict((k[0], float(k[1:][0])) for k in core_shield_dict)\n        core_shield = []\n\n        for i in filename.get_chemical_symbols():\n            core_shield.append(core_shield_dict[i])\n\n    #Process results\n    efg = np.array(efg,dtype=float) #resulting EFG matrix\n    efg = efg * 1e20 / const.physical_constants[\"atomic unit of electric field gradient\"][0]\n    sym_tensor = np.split(np.array(sym_tensor,dtype=float), n_atoms) #symmetry tensors\n    const_shield = np.array(const_shield, dtype=float) #constant shielding of the lattice\n    core_shield = np.array(core_shield,dtype=float) #core shielding depending on atom type\n\n    for i in range(n_atoms):\n        core_diag = np.diag(core_shield[i] * np.ones(3))\n        ms_tensor = sym_tensor[i] + const_shield + core_diag + mag_sus/chi_fact*1e6*np.eye(3) #calculating MS tensor\n        ms.append(-ms_tensor)  # calculating MS tensors\n    ms=np.array(np.array(ms).tolist(),dtype=float) #processing MS tensor to work with ase\n\n    filename.set_array('efg', efg)\n    filename.set_array('ms', ms)\n\n    return filename\n</code></pre>"},{"location":"reference/simpyson/gui.html","title":"gui","text":""},{"location":"reference/simpyson/io.html","title":"io","text":""},{"location":"reference/simpyson/io.html#simpyson.io.SimpReader","title":"SimpReader","text":"<pre><code>SimpReader(filename, format, b0=None, nucleus=None)\n</code></pre> <p>A class to read and process NMR data from SIMPSON files.</p> <p>Attributes:     filename (str): The name of the file to read.     format (str): The format of the file (spe, fid, xreim).     b0 (str, optional): The magnetic field strength in MHz or T.     nucleus (str, optional): The nucleus type.</p> <p>Example:     reader = SimpReader('spe_file', 'spe', b0='9.4T', nucleus='13C')</p> Source code in <code>simpyson/io.py</code> <pre><code>def __init__(self, filename, format, b0=None, nucleus=None):\n    self.filename = filename\n    self.format = format\n    self.b0 = b0\n    self.nucleus = nucleus\n    self._read_file()\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.SimpReader.to_fid","title":"to_fid","text":"<pre><code>to_fid()\n</code></pre> <p>Converts spectrum (SPE) data to FID.</p> <p>Raises:     ValueError: If the format is not SPE.</p> <p>Returns:     SimpReader: A new SimpReader instance with FID format data.</p> Source code in <code>simpyson/io.py</code> <pre><code>def to_fid(self):\n    \"\"\"\n    Converts spectrum (SPE) data to FID.\n\n    Raises:\n        ValueError: If the format is not SPE.\n\n    Returns:\n        SimpReader: A new SimpReader instance with FID format data.\n    \"\"\"\n    if self.format != 'spe':\n        raise ValueError('Only SPE format can be converted to FID.')\n\n    fid = copy.deepcopy(self)\n\n    npoints = fid.data['np']\n    sw = fid.data['sw']\n    hz = fid.data['hz']\n    signal = fid.data['real'] + 1j * fid.data['imag']\n    signal = np.fft.ifft(np.fft.ifftshift(signal))\n    real = np.real(signal)\n    imag = np.imag(signal)\n    dt = 1.0 / sw\n    time = np.linspace(0, npoints*dt, int(npoints)) * 10e3  # Match _read_fid scaling\n    fid.data = {'real': real, 'imag': imag, 'np': npoints, 'sw': sw, 'time': time}\n\n    fid.format = 'fid'\n\n    return fid\n</code></pre>"},{"location":"reference/simpyson/io.html#simpyson.io.SimpReader.to_spe","title":"to_spe","text":"<pre><code>to_spe()\n</code></pre> <p>Converts FID data to spectrum (SPE).</p> <p>Raises:     ValueError: If the format is not FID.</p> <p>Returns:     SimpReader: A new SimpReader instance with SPE format data.</p> <p>Example:     spectrum = reader.to_spe()</p> Source code in <code>simpyson/io.py</code> <pre><code>def to_spe(self):\n    \"\"\"\n    Converts FID data to spectrum (SPE).\n\n    Raises:\n        ValueError: If the format is not FID.\n\n    Returns:\n        SimpReader: A new SimpReader instance with SPE format data.\n\n    Example:\n        spectrum = reader.to_spe()\n    \"\"\"\n    if self.format != 'fid':\n        raise ValueError('Only FID format can be converted to SPE.')\n\n    spectrum = copy.deepcopy(self)\n\n    npoints = spectrum.data['np']\n    sw = spectrum.data['sw']\n    raw_signal = spectrum.data['real'] + 1j * spectrum.data['imag']\n    signal = np.fft.fftshift(np.fft.fft(raw_signal))\n    real = np.real(signal)\n    imag = np.imag(signal)\n    hz = np.linspace(-sw/2, sw/2, int(npoints))\n    spectrum.data = {'real': real, 'imag': imag, 'np': npoints, 'sw': sw, 'hz': hz}\n\n    if spectrum.b0 is not None and spectrum.nucleus is not None:\n        try:\n            spectrum.data['ppm'] = hz2ppm(hz, spectrum.b0, spectrum.nucleus)\n        except ValueError as e:\n            print(f\"Error converting to ppm: {e}\")\n\n    return spectrum\n</code></pre>"},{"location":"reference/simpyson/templates.html","title":"templates","text":""},{"location":"reference/simpyson/templates.html#simpyson.templates.SimpSim","title":"SimpSim","text":"<pre><code>SimpSim(spinsys, out_name, out_format, spin_rate, np, proton_freq, start_op, detect_op, crystal_file, gamma_angles, sw, verbose, lb, zerofill, method='direct', tsw=None, pulse_sequence=None, pH=None, pX=None, pY=None, plH=None, plX=None, plY=None, phH=None, phX=None, phY=None)\n</code></pre> <p>Class to create a SIMPSON simulation input.</p> <p>Attributes:     spinsys (str): Spin system from Soprano or a custom string.     out_name (str): Output file name.     out_format (str): Output format (fid, spe, xreim).     spin_rate (float): Spin rate in Hz.     np (int): Number of points.     proton_freq (float): Proton frequency in Hz.     start_op (str): Start operator.     detect_op (str): Detect operator.     crystal_file (str): Crystal file.     gamma_angles (str): Gamma angles.     sw (float): Spectral width.     verbose (bool): Verbose output.     lb (float): Line broadening.     zerofill (int): Zero filling.     method (str): Method of simulation (direct, indirect, ...).     tsw (str, optional): Spectral width in time domain.     pulse_sequence (str, optional): Pulse sequence from templates or a custom string.     pH (float, optional): pulse for H in us.     pX (float, optional): pulse for X in us.     pY (float, optional): pulse for Y in us.     plH (float, optional): power level for H in Hz.     plX (float, optional): power level for X in Hz.     plY (float, optional): power level for Y in Hz.     phH (float, optional): phase for H pH.     phX (float, optional): phase for X pH.     phY (float, optional): phase for Y pH.</p> <p>Example:     sim = SimpSim(spinsys=spinsys, out_name='output', out_format='spe', spin_rate=15e3, np=2048, proton_freq=400e6, start_op='Inx', detect_op='Inp', crystal_file='rep100', gamma_angles=4, sw=20e3, verbose=0, lb=20, zerofill=4096)</p> Source code in <code>simpyson/templates.py</code> <pre><code>def __init__(self, spinsys, out_name, out_format, spin_rate, np, proton_freq, start_op, detect_op, crystal_file, gamma_angles, sw, verbose, lb, zerofill, method=\"direct\", tsw=None, pulse_sequence=None, pH=None, pX=None, pY=None, plH=None, plX=None, plY=None, phH=None, phX=None, phY=None):\n    self.spin_rate = spin_rate\n    self.spinsys = spinsys\n    self.out_name = out_name\n    self.out_format = out_format\n    self.np = np\n    self.proton_freq = proton_freq\n    self.start_op = start_op\n    self.detect_op = detect_op\n    self.crystal_file = crystal_file\n    self.gamma_angles = gamma_angles\n    self.sw = sw\n    self.verbose = verbose\n    self.tsw = tsw if tsw else f\"1e6/{sw}\"\n    self.lb = lb\n    self.zerofill = zerofill\n    self.method = method\n    self.pulse_sequence = pulse_sequence\n    self.pH = pH\n    self.pX = pX\n    self.pY = pY\n    self.plH = plH\n    self.plX = plX\n    self.plY = plY\n    self.phH = phH\n    self.phX = phX\n    self.phY = phY\n</code></pre>"},{"location":"user_guide/read_files.html","title":"Read Simpson files","text":"<pre><code>from simpyson.io import SimpReader\nimport matplotlib.pyplot as plt\n</code></pre> <p>In the <code>examples</code> folder, you can find the files <code>ethanol.in</code>, <code>ethanol.fid</code>, and <code>ethanol.spe</code>.</p> <ul> <li><code>ethanol.in</code> is a standard input file for a SIMPSON simulation of the ethanol molecule.</li> <li><code>ethanol.fid</code> represents the simulated free induction decay (FID) of the ethanol molecule.</li> <li><code>ethanol.spe</code> represents the NMR spectra of the ethanol molecule.</li> </ul> <p>SimPYson provides the <code>SimpReader</code> class, which reads a SIMPSON <code>fid</code>, <code>spe</code> and <code>xreim</code> files. When a <code>fid</code> file is read <code>SimpReader</code> creates a Python object with the following data:</p> <ul> <li><code>real</code> - The real part of the FID.</li> <li><code>imag</code> - The imaginary part of the FID.</li> <li><code>np</code> - The number of points.</li> <li><code>sw</code>  - The spectral width.</li> <li><code>time</code> - The time in milliseconds.</li> </ul> <pre><code>fid = SimpReader('../../examples/read/ethanol.fid', format='fid')\n\nfor key, values in fid.data.items():\n    print(key, values)\n</code></pre> <pre>\n<code>real [95.9999136 63.5468932 20.9678205 ...  0.         0.         0.       ]\nimag [ 0.        52.0761046 48.2650021 ...  0.         0.         0.       ]\nnp 4096.0\nsw 10000.0\ntime [0.00000000e+00 1.00024420e+00 2.00048840e+00 ... 4.09399951e+03\n 4.09499976e+03 4.09600000e+03]\n</code>\n</pre> <p>The data can be easily plotted using matplotlib</p> <pre><code>plt.plot(fid.data['time'], fid.data['real'])\nplt.xlabel('Time (ms)')\nplt.show()\n</code></pre> <p>When reading <code>spe</code> files the following data is extracted:</p> <ul> <li><code>real</code> - The real part of the spectrum.</li> <li><code>imag</code> - The imaginary part of the spectrum.</li> <li><code>np</code> - The number of points.</li> <li><code>sw</code>  - The spectral width.</li> <li><code>hz</code> - The frequency in Hz.</li> </ul> <pre><code>spe = SimpReader('../../examples/read/ethanol.spe', format='spe')\n\nfor key, value in spe.data.items():\n    print(key, value)\n</code></pre> <pre>\n<code>real [0.18006085 0.19032725 0.1798519  ... 0.19060431 0.18027098 0.19046516]\nimag [-20.1918974 -20.1791859 -20.0945303 ... -20.3742075 -20.2894344\n -20.2766117]\nnp 4096.0\nsw 10000.0\nhz [-5000.         -4997.55799756 -4995.11599512 ...  4995.11599512\n  4997.55799756  5000.        ]\n</code>\n</pre> <p>The <sup>1</sup>H NMR spectra of ethanol show 3 <sup>1</sup>H NMR peaks: - Triplet from the CH<sub>3</sub> group - Quartet from the CH<sub>2</sub> group - Single from the OH group</p> <p>You can edit <code>jcoupling</code> in the file <code>examples/ethanol.in</code> to see the effect of J-coupling on the spliting of the <sup>1</sup>H peaks</p> <pre><code>plt.plot(spe.data['hz'], spe.data['real'])\nplt.xlabel('Frequency (Hz)')\nplt.xlim(3000, 0)\nplt.show()\n</code></pre> <p>The data can be converted from frequency (Hz) to ppm by providing the external magnetic field (B<sub>0</sub>) in either Tesla or MHz, and specify the nucleus being observed</p> <pre><code>spe_ppm = SimpReader('../../examples/read/ethanol.spe', format='spe', b0='400MHz', nucleus='1H')\nplt.plot(spe_ppm.data['ppm'], spe_ppm.data['real'])\nplt.xlabel('$^1$H (ppm)')\nplt.xlim(8, 0)\nplt.show()\n</code></pre> <p>Lastly, you can convert any <code>fid</code> file into a <code>spe</code> easily by using <code>.to_spe()</code></p> <pre><code>conv_spe = fid.to_spe()\n\nplt.plot(conv_spe.data['hz'], conv_spe.data['real'], label = 'Converted')\nplt.plot(spe.data['hz'], spe.data['real'], label = 'Original')\nplt.xlim(3000, 0)\nplt.xlabel('Frequency (Hz)')\nplt.legend()\n</code></pre> <pre>\n<code>&lt;matplotlib.legend.Legend at 0x17fa580d790&gt;</code>\n</pre> <p>The data can be easily exported to a <code>.csv</code> file</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame(fid.data)\ndf.to_csv('../../examples/read/fid.csv', index=False)\n</code></pre>"},{"location":"user_guide/read_files.html#read-simpson-files-with-simpyson","title":"Read SIMPSON files with SimPYson","text":""},{"location":"user_guide/write_simpson.html","title":"Prepare Simpson simulations","text":"<p>A Simpson input file is typically divided into four main sections:</p> <ol> <li>Spin System: This section identifies the nuclei to be simulated and includes their NMR parameters, such as isotropic shift, asymmetry, and Euler angles.</li> <li>Parameters: This defines the settings for the \"virtual spectrometer,\" such as the magnetic field strength (<code>proton_freq</code>), spinning rate (<code>spin_rate</code>), number of points (<code>np</code>), pulse lengths, pulse powers, etc.</li> <li>Pulse Sequence: This part specifies the pulse program used in the simulation.</li> <li>Processing: Defines the processing parameters, such as line broadening (<code>lb</code>) or Fourier transformation of the FID signal.</li> </ol> <p>Simpyson simplifies the preparation of these input files by interfacing data from DFT calculations with Simpson, using ASE. The spin system for magres files from CASTEP and Quantum Espresso NMR calculations can be easily generated with Soprano, while Simpyson can handle the rest of the input file.</p> <p>For a more detailed description of each parameter, please refer to the following Simpson papers Bak et al, To\u0161ner et al., and Juhl et al.</p> <pre><code>from soprano.calculate.nmr.simpson import write_spinsys\nfrom ase.io import read\nfrom simpyson.converter import read_vasp\nfrom simpyson.templates import SimpSim, no_pulse\nfrom simpyson.io import SimpReader\nimport matplotlib.pyplot as plt\n</code></pre> <p>In the following example, we start by reading the structure from an ethanol CASTEP calculation, selecting the H atoms, referencing the chemical shifts (<code>grad = {'H' : -1}</code> and <code>ref = {'H' : 31.7}</code>), and construct the input file for a spectrum acquired at 400 MHz (<code>spin_rate = 40e3</code>) with a spinning rate of 40 kHz (<code>spin_rate = 40e3</code>). To keep the simulation simple, we begin with the magnetization in the xy-plane (<code>start_op = 'Inx'</code>), i.e. the detection plane, thus removing the need to due pulses. For this, we can use the <code>no_pulse</code> sequence.</p> <pre><code># Read magres file\nethanol = read('../../examples/write/ethanol.magres')\n\n# Select only the H atoms\nh_idx = [atom.index for atom in ethanol if atom.symbol == 'H']\nH_subset = ethanol[h_idx]\n\n# Get spin system\nspinsys = write_spinsys(H_subset,\n            use_ms = True,\n            grad = {'H' : -1},\n            ref = {'H' : 31.7})\n\n# Prepare Simpson simulation\nsimp_in = SimpSim(\n    out_name = 'ethanol_sim',\n    out_format = 'spe',\n    spinsys = spinsys,\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 400e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep256',\n    gamma_angles = 6,\n    sw = 10e3,\n    verbose = '01',\n    lb = 10,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 1e4,\n    pulse_sequence = no_pulse,\n)\n\n# Write input file\nsimp_in.save('../../examples/write/ethanol_sim.in')\n</code></pre> <p>The results can be easily plotted. The difference between this spectrum and the one from the previous tutorial is due to the absence of J-coupling in this simulation.</p> <pre><code>ethanol_out = SimpReader('../../examples/write/ethanol_sim.spe', b0='400MHz', nucleus='1H', format='spe')\n\nplt.plot(ethanol_out.data['ppm'], ethanol_out.data['real'])\nplt.xlim(8, 0)\nplt.xlabel('$^1$H (ppm)')\nplt.show()\n</code></pre> <p>Unlike CASTEP and Quantum Espresso <code>magres</code> files, VASP's OUTCAR file contains the magnetic shielding and electric field gradient tensors in units that are not in Hz, as required by Soprano and Simpson. Additionally, ASE\u2019s read function doesn\u2019t automatically add the <code>ms</code> and <code>efg</code> arrays to the <code>Atoms</code> object, which are necessary for Soprano to prepare the spin system. The <code>read_vasp</code> function handles these conversions and adds the required information. Here is one example how to use it, and how the results compare with a similar CASTEP calculation.</p> <pre><code># Castep calculation\ncastep = read('../../examples/write/AlPO-14.magres')\n\np_idx = [atom.index for atom in castep if atom.symbol == 'P']\np_subset = castep[p_idx]\nal_idx = [atom.index for atom in castep if atom.symbol == 'Al']\nal_subset = castep[al_idx]\n\np_spinsys = write_spinsys(p_subset,\n            use_ms = True,\n            grad = {'P' : -1},\n            ref = {'P' : 283.839})\n\n\n# Al is a quadrupolar so it is important to consider the quadrupolar interaction\n# Simpson allows simulation of quadrupolar broadening up to 2nd order\nal_spinsys = write_spinsys(al_subset,\n            use_ms = True,\n            grad = {'Al' : -1},\n            ref = {'Al' : 538.78},\n            q_order=2)\n\np_inp = SimpSim(\n    out_name = 'castep_sim_p',\n    out_format = 'spe',\n    spinsys = p_spinsys,\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 30e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 3e4,\n    pulse_sequence = no_pulse,\n)\n\nal_inp = SimpSim(\n    out_name = 'castep_sim_al',\n    out_format = 'spe',\n    spinsys = al_spinsys,\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inc',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 20e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 2e4,\n    pulse_sequence = no_pulse,\n)\n\np_inp.save('../../examples/write/castep_sim_p.in')\nal_inp.save('../../examples/write/castep_sim_al.in')\n\n\n# VASP calculation\nvasp = read_vasp('../../examples/write/AlPO-14.OUTCAR', format='vasp-out')\n\np_idx = [atom.index for atom in vasp if atom.symbol == 'P']\np_subset = vasp[p_idx]\nal_idx = [atom.index for atom in vasp if atom.symbol == 'Al']\nal_subset = vasp[al_idx]\n\np_spinsys = write_spinsys(p_subset,\n            use_ms = True,\n            grad = {'P' : -1},\n            ref = {'P' : 294.50})\n\nal_spinsys = write_spinsys(al_subset,\n            use_ms = True,\n            grad = {'Al' : -1},\n            ref = {'Al' : 542.96},\n            q_order=2)\n\np_inp = SimpSim(\n    out_name = 'vasp_sim_p',\n    out_format = 'spe',\n    spinsys = p_spinsys,\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inp',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 30e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 3e4,\n    pulse_sequence = no_pulse,\n)\n\nal_inp = SimpSim(\n    out_name = 'vasp_sim_al',\n    out_format = 'spe',\n    spinsys = al_spinsys,\n    spin_rate = 40e3,\n    np = 2048,\n    proton_freq = 800e6,\n    start_op = 'Inx',\n    detect_op = 'Inc',\n    crystal_file = 'rep168',\n    gamma_angles = 6,\n    sw = 20e3,\n    verbose = '01',\n    lb = 200,\n    zerofill = 4096,\n    method = \"direct\",\n    tsw = 2e4,\n    pulse_sequence = no_pulse,\n)\n\np_inp.save('../../examples/write/vasp_sim_p.in')\nal_inp.save('../../examples/write/vasp_sim_al.in')\n</code></pre> <p>Unless you have a laptop/node with crazy amounts of memory, simulating the full Al spin system, containing 8 Al atoms each with second-order quadrupolar broadening <code>q_order = 2</code>, can be quite challenging. Since we're not considering coupling between the Al atoms, a more efficient approach is to prepare an input file for each individual Al atom and then merge all the spectra into a combined spectrum. This reduces the computational load and makes the simulation much more manageable.</p> <pre><code># Prepare Simpson for each Al atom of CASTEP\nal_idx = [atom.index for atom in castep if atom.symbol == 'Al']\n\nfor i, atom in enumerate(al_idx):\n    al_subset = castep[[atom]]\n    al_spinsys = write_spinsys(al_subset,\n                use_ms = True,\n                grad = {'Al' : -1},\n                ref = {'Al' : 538.78},\n                q_order=2)\n\n    al_inp = SimpSim(\n        out_name = f'castep_sim_al_{i}',\n        out_format = 'spe',\n        spinsys = al_spinsys,\n        spin_rate = 40e3,\n        np = 2048,\n        proton_freq = 800e6,\n        start_op = 'Inx',\n        detect_op = 'Inc',\n        crystal_file = 'rep168',\n        gamma_angles = 6,\n        sw = 20e3,\n        verbose = '01',\n        lb = 200,\n        zerofill = 4096,\n        method = \"direct\",\n        tsw = 2e4,\n        pulse_sequence = no_pulse,\n    )\n\n    al_inp.save(f'../../examples/write/split_simulation_al/castep_sim_al_{i}.in')\n\n# Prepare Simpson for each Al atom of VASP\nal_idx = [atom.index for atom in vasp if atom.symbol == 'Al']\n\nfor i, atom in enumerate(al_idx):\n    al_subset = vasp[[atom]]\n    al_spinsys = write_spinsys(al_subset,\n                use_ms = True,\n                grad = {'Al' : -1},\n                ref = {'Al' : 542.96},\n                q_order=2)\n\n    al_inp = SimpSim(\n        out_name = f'vasp_sim_al_{i}',\n        out_format = 'spe',\n        spinsys = al_spinsys,\n        spin_rate = 40e3,\n        np = 2048,\n        proton_freq = 800e6,\n        start_op = 'Inx',\n        detect_op = 'Inc',\n        crystal_file = 'rep168',\n        gamma_angles = 6,\n        sw = 20e3,\n        verbose = '01',\n        lb = 200,\n        zerofill = 4096,\n        method = \"direct\",\n        tsw = 2e4,\n        pulse_sequence = no_pulse,\n    )\n\n    al_inp.save(f'../../examples/write/split_simulation_al/vasp_sim_al_{i}.in')\n</code></pre> <p>Now let's combined all the <sup>27</sup>Al spectra and plot the results.</p> <pre><code># Read CASTEP Al simulations\nreal = []\nimag = []\nfor i in range(0, len(al_idx)):\n    castep_al_out = SimpReader(f'../../examples/write/split_simulation_al/castep_sim_al_{i}.spe', b0='800MHz', nucleus='27Al', format='spe')\n    real.append(castep_al_out.data['real'])\n    imag.append(castep_al_out.data['imag'])\n\n# Read one example and update the data\ncastep_al_out = SimpReader('../../examples/write/split_simulation_al/castep_sim_al_0.spe', b0='800MHz', nucleus='27Al', format='spe')\ncastep_al_out.data['real'] = sum(real)\ncastep_al_out.data['imag'] = sum(imag)\n\n# Do the same of VASP\nreal = []\nimag = []\nfor i in range(0, len(al_idx)):\n    vasp_al_out = SimpReader(f'../../examples/write/split_simulation_al/vasp_sim_al_{i}.spe', b0='800MHz', nucleus='27Al', format='spe')\n    real.append(vasp_al_out.data['real'])\n    imag.append(vasp_al_out.data['imag'])\n\nvasp_al_out = SimpReader('../../examples/write/split_simulation_al/vasp_sim_al_0.spe', b0='800MHz', nucleus='27Al', format='spe')\nvasp_al_out.data['real'] = sum(real)\nvasp_al_out.data['imag'] = sum(imag)\n\ncastep_p_out = SimpReader('../../examples/write/castep_sim_p.spe', b0='800MHz', nucleus='31P', format='spe')\nvasp_p_out = SimpReader('../../examples/write/vasp_sim_p.spe', b0='800MHz', nucleus='31P', format='spe')\n\nfig, ax = plt.subplots(1, 2, figsize=(10, 5))\nax[0].plot(castep_p_out.data['ppm'], castep_p_out.data['real'])\nax[0].plot(vasp_p_out.data['ppm'], vasp_p_out.data['real'])\nax[0].set_xlabel('$^{31}$P (ppm)')\nax[0].set_xlim(-10, -45)\nax[0].legend(['CASTEP', 'VASP'])\n\nax[1].plot(castep_al_out.data['ppm'], castep_al_out.data['real'])\nax[1].plot(vasp_al_out.data['ppm'], vasp_al_out.data['real'])\nax[1].set_xlabel('$^{27}$Al (ppm)')\nax[1].set_xlim(45, 0)\nax[1].legend(['CASTEP', 'VASP'])\nplt.show()\n</code></pre>"},{"location":"user_guide/write_simpson.html#write-simpson-simulation-files","title":"Write Simpson simulation files","text":""},{"location":"user_guide/write_simpson.html#read-vasp-nmr-calculations","title":"Read VASP NMR calculations","text":""}]}